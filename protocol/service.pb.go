// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	service.proto

It has these top-level messages:
	Chunk
	File
	UploadStatus
*/
package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_Unknown StatusCode = 0
	StatusCode_Ok      StatusCode = 1
	StatusCode_Failed  StatusCode = 2
)

var StatusCode_name = map[int32]string{
	0: "Unknown",
	1: "Ok",
	2: "Failed",
}
var StatusCode_value = map[string]int32{
	"Unknown": 0,
	"Ok":      1,
	"Failed":  2,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Chunk struct {
	Filepath       string `protobuf:"bytes,1,opt,name=Filepath" json:"Filepath,omitempty"`
	SizeInBytes    int64  `protobuf:"varint,2,opt,name=SizeInBytes" json:"SizeInBytes,omitempty"`
	SizeTotalBytes int64  `protobuf:"varint,3,opt,name=SizeTotalBytes" json:"SizeTotalBytes,omitempty"`
	Content        []byte `protobuf:"bytes,4,opt,name=Content,proto3" json:"Content,omitempty"`
	IsLastChunk    bool   `protobuf:"varint,5,opt,name=IsLastChunk" json:"IsLastChunk,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Chunk) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *Chunk) GetSizeInBytes() int64 {
	if m != nil {
		return m.SizeInBytes
	}
	return 0
}

func (m *Chunk) GetSizeTotalBytes() int64 {
	if m != nil {
		return m.SizeTotalBytes
	}
	return 0
}

func (m *Chunk) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Chunk) GetIsLastChunk() bool {
	if m != nil {
		return m.IsLastChunk
	}
	return false
}

type File struct {
	Filepath string `protobuf:"bytes,1,opt,name=Filepath" json:"Filepath,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *File) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

type UploadStatus struct {
	Filepath string     `protobuf:"bytes,1,opt,name=Filepath" json:"Filepath,omitempty"`
	Code     StatusCode `protobuf:"varint,2,opt,name=Code,enum=protocol.StatusCode" json:"Code,omitempty"`
}

func (m *UploadStatus) Reset()                    { *m = UploadStatus{} }
func (m *UploadStatus) String() string            { return proto.CompactTextString(m) }
func (*UploadStatus) ProtoMessage()               {}
func (*UploadStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UploadStatus) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *UploadStatus) GetCode() StatusCode {
	if m != nil {
		return m.Code
	}
	return StatusCode_Unknown
}

func init() {
	proto.RegisterType((*Chunk)(nil), "protocol.Chunk")
	proto.RegisterType((*File)(nil), "protocol.File")
	proto.RegisterType((*UploadStatus)(nil), "protocol.UploadStatus")
	proto.RegisterEnum("protocol.StatusCode", StatusCode_name, StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GRPCFileService service

type GRPCFileServiceClient interface {
	Download(ctx context.Context, in *File, opts ...grpc.CallOption) (GRPCFileService_DownloadClient, error)
	Upload(ctx context.Context, opts ...grpc.CallOption) (GRPCFileService_UploadClient, error)
}

type gRPCFileServiceClient struct {
	cc *grpc.ClientConn
}

func NewGRPCFileServiceClient(cc *grpc.ClientConn) GRPCFileServiceClient {
	return &gRPCFileServiceClient{cc}
}

func (c *gRPCFileServiceClient) Download(ctx context.Context, in *File, opts ...grpc.CallOption) (GRPCFileService_DownloadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GRPCFileService_serviceDesc.Streams[0], c.cc, "/protocol.GRPCFileService/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &gRPCFileServiceDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GRPCFileService_DownloadClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type gRPCFileServiceDownloadClient struct {
	grpc.ClientStream
}

func (x *gRPCFileServiceDownloadClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gRPCFileServiceClient) Upload(ctx context.Context, opts ...grpc.CallOption) (GRPCFileService_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GRPCFileService_serviceDesc.Streams[1], c.cc, "/protocol.GRPCFileService/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &gRPCFileServiceUploadClient{stream}
	return x, nil
}

type GRPCFileService_UploadClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*UploadStatus, error)
	grpc.ClientStream
}

type gRPCFileServiceUploadClient struct {
	grpc.ClientStream
}

func (x *gRPCFileServiceUploadClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gRPCFileServiceUploadClient) CloseAndRecv() (*UploadStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GRPCFileService service

type GRPCFileServiceServer interface {
	Download(*File, GRPCFileService_DownloadServer) error
	Upload(GRPCFileService_UploadServer) error
}

func RegisterGRPCFileServiceServer(s *grpc.Server, srv GRPCFileServiceServer) {
	s.RegisterService(&_GRPCFileService_serviceDesc, srv)
}

func _GRPCFileService_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(File)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GRPCFileServiceServer).Download(m, &gRPCFileServiceDownloadServer{stream})
}

type GRPCFileService_DownloadServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type gRPCFileServiceDownloadServer struct {
	grpc.ServerStream
}

func (x *gRPCFileServiceDownloadServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _GRPCFileService_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GRPCFileServiceServer).Upload(&gRPCFileServiceUploadServer{stream})
}

type GRPCFileService_UploadServer interface {
	SendAndClose(*UploadStatus) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type gRPCFileServiceUploadServer struct {
	grpc.ServerStream
}

func (x *gRPCFileServiceUploadServer) SendAndClose(m *UploadStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gRPCFileServiceUploadServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GRPCFileService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.GRPCFileService",
	HandlerType: (*GRPCFileServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Download",
			Handler:       _GRPCFileService_Download_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Upload",
			Handler:       _GRPCFileService_Upload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "service.proto",
}

func init() { proto.RegisterFile("service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x50, 0xdf, 0x6a, 0xfa, 0x30,
	0x18, 0x35, 0xfe, 0xa9, 0xfd, 0x7d, 0xfa, 0x53, 0xf9, 0x18, 0xa3, 0xf4, 0xaa, 0xf4, 0x62, 0x84,
	0xc1, 0xba, 0xe1, 0xd8, 0x0b, 0xac, 0xc3, 0x21, 0x0c, 0x36, 0x52, 0x7d, 0x80, 0xcc, 0x06, 0x2c,
	0x2d, 0x49, 0xb1, 0x71, 0xe2, 0xde, 0x68, 0x6f, 0x39, 0x92, 0xe2, 0x5a, 0xbc, 0xf0, 0x2a, 0x9c,
	0x3f, 0xe1, 0x9c, 0xf3, 0xc1, 0xff, 0x4a, 0xec, 0xbe, 0xb2, 0x8d, 0x88, 0xca, 0x9d, 0xd2, 0x0a,
	0x5d, 0xfb, 0x6c, 0x54, 0x11, 0xfe, 0x10, 0x18, 0xc4, 0xdb, 0xbd, 0xcc, 0xd1, 0x07, 0x77, 0x91,
	0x15, 0xa2, 0xe4, 0x7a, 0xeb, 0x91, 0x80, 0xd0, 0x7f, 0xec, 0x0f, 0x63, 0x00, 0xa3, 0x24, 0xfb,
	0x16, 0x4b, 0xf9, 0x7c, 0xd4, 0xa2, 0xf2, 0xba, 0x01, 0xa1, 0x3d, 0xd6, 0xa6, 0xf0, 0x06, 0x26,
	0x06, 0xae, 0x94, 0xe6, 0x45, 0x6d, 0xea, 0x59, 0xd3, 0x19, 0x8b, 0x1e, 0x0c, 0x63, 0x25, 0xb5,
	0x90, 0xda, 0xeb, 0x07, 0x84, 0x8e, 0xd9, 0x09, 0x9a, 0x8c, 0x65, 0xf5, 0xc6, 0x2b, 0x6d, 0xeb,
	0x78, 0x83, 0x80, 0x50, 0x97, 0xb5, 0xa9, 0x30, 0x84, 0xbe, 0x69, 0x74, 0xa9, 0x69, 0xb8, 0x82,
	0xf1, 0xba, 0x2c, 0x14, 0x4f, 0x13, 0xcd, 0xf5, 0xbe, 0xba, 0xb8, 0x8a, 0x42, 0x3f, 0x56, 0xa9,
	0xb0, 0x73, 0x26, 0xf3, 0xab, 0xe8, 0x74, 0x94, 0xa8, 0xfe, 0x6b, 0x34, 0x66, 0x1d, 0xb7, 0x77,
	0x00, 0x0d, 0x87, 0x23, 0x18, 0xae, 0x65, 0x2e, 0xd5, 0x41, 0xce, 0x3a, 0xe8, 0x40, 0xf7, 0x3d,
	0x9f, 0x11, 0x04, 0x70, 0x16, 0x3c, 0x2b, 0x44, 0x3a, 0xeb, 0xce, 0x8f, 0x30, 0x7d, 0x65, 0x1f,
	0xb1, 0x09, 0x4a, 0xea, 0xbb, 0xe3, 0x3d, 0xb8, 0x2f, 0xea, 0x20, 0x4d, 0x33, 0x9c, 0x34, 0x49,
	0xc6, 0xe2, 0x4f, 0x1b, 0x5c, 0x0f, 0xed, 0x3c, 0x10, 0x7c, 0x02, 0xa7, 0x1e, 0x82, 0xe7, 0xb2,
	0x7f, 0xdd, 0x10, 0xed, 0xad, 0x61, 0x87, 0x92, 0x4f, 0xc7, 0x4a, 0x8f, 0xbf, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x70, 0x55, 0xa5, 0x23, 0xf1, 0x01, 0x00, 0x00,
}
